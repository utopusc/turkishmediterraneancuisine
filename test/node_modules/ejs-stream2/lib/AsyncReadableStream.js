"use strict";
/*!
 * Copyright 2019 yangjunbao <yangjunbao@shimo.im>. All rights reserved.
 * @since 2019-10-10 12:08:58
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const is_stream_1 = tslib_1.__importDefault(require("is-stream"));
const stream_1 = require("stream");
class AsyncReadableStream extends stream_1.Readable {
    constructor(options = {}) {
        super(options);
        this.chunks = [];
        this.current = void 0;
        this.nextSize = void 0;
        this.isStoped = false;
        this.handleError = (e) => {
            this.destroy(e);
        };
        this.handleData = (chunk) => {
            this.nextSize = void 0;
            this.push(chunk);
        };
        this.handleEnd = () => {
            this.removeHandlers(this.current);
            const nextSize = this.nextSize;
            this.current = void 0;
            this.nextSize = void 0;
            if (nextSize !== void 0) {
                this._read(nextSize);
            }
        };
    }
    pushChunk(chunk) {
        if (this.isStoped) {
            return;
        }
        if (Array.isArray(chunk)) {
            for (const item of chunk) {
                this.pushChunk(item);
            }
        }
        else if (chunk) {
            this.chunks.push(chunk);
            if (!this.current && this.nextSize !== void 0) {
                this._read(this.nextSize);
            }
        }
    }
    end() {
        this.isStoped = true;
    }
    removeHandlers(chunk) {
        if (is_stream_1.default.readable(chunk)) {
            chunk.removeListener('data', this.handleData);
            chunk.removeListener('error', this.handleError);
            chunk.removeListener('end', this.handleEnd);
        }
    }
    _read(size) {
        if (this.current) {
            this.nextSize = size || 0;
            return;
        }
        if (this.chunks.length === 0) {
            if (this.isStoped) {
                this.push(null);
            }
            else {
                this.nextSize = size;
            }
            return;
        }
        const chunk = this.chunks.shift();
        if (is_stream_1.default.readable(chunk)) {
            this.current = chunk;
            chunk.on('error', this.handleError);
            chunk.on('data', this.handleData);
            chunk.on('end', this.handleEnd);
        }
        else if (chunk instanceof Promise) {
            chunk.then((data) => this.push(data || ''), (reason) => this.destroy(reason));
        }
        else {
            this.push(chunk || '');
        }
    }
    _destroy(error, callback) {
        this.removeHandlers(this.current);
        this.current = void 0;
        this.nextSize = void 0;
        callback(error);
    }
}
exports.AsyncReadableStream = AsyncReadableStream;
//# sourceMappingURL=AsyncReadableStream.js.map