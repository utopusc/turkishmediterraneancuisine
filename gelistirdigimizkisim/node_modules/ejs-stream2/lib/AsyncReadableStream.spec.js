"use strict";
/*!
 * Copyright 2019 yangjunbao <yangjunbao@shimo.im>. All rights reserved.
 * @since 2019-10-10 12:25:48
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const AsyncReadableStream_1 = require("./AsyncReadableStream");
const utils_1 = require("./utils");
describe('AsyncReadableStream', () => {
    it('should process chunks correctly', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const asyncReadable = new AsyncReadableStream_1.AsyncReadableStream();
        asyncReadable.pushChunk('string'); // string
        asyncReadable.pushChunk(Buffer.from('buffer')); // buffer
        asyncReadable.pushChunk(utils_1.createReadable(2)); // readable stream
        asyncReadable.pushChunk(utils_1.sleep(1).then(() => 'promise')); // promise
        asyncReadable.pushChunk([
            'array-string',
            utils_1.sleep(1).then(() => 'array-promise'),
            utils_1.createReadable(2, 'array-readable-'),
        ]);
        asyncReadable.pushChunk(undefined);
        asyncReadable.pushChunk('between-nullable');
        asyncReadable.pushChunk(null);
        asyncReadable.pushChunk([null, undefined, 'with-nullable']);
        asyncReadable.pushChunk('final-string');
        asyncReadable.end();
        const chunks = yield utils_1.resolveReadable(asyncReadable);
        expect(chunks).toEqual([
            'string',
            'buffer',
            'readable-2',
            'readable-1',
            'promise',
            'array-string',
            'array-promise',
            'array-readable-2',
            'array-readable-1',
            'between-nullable',
            'with-nullable',
            'final-string',
        ]);
    }));
});
//# sourceMappingURL=AsyncReadableStream.spec.js.map